问题描述
　　给定一个信封，有N（1≤N≤100）个位置可以贴邮票，每个位置只能贴一张邮票。我们现在有M(M<=100)种不同邮资的邮票，面值为X1,X2….Xm分（Xi是整数，1≤Xi≤255），每种都有N张。

　　显然，信封上能贴的邮资最小值是min(X1, X2, …, Xm)，最大值是 N*max(X1, X2, …,　　Xm)。由所有贴法得到的邮资值可形成一个集合（集合中没有重复数值），要求求出这个集合中是否存在从1到某个值的连续邮资序列，输出这个序列的最大值。

　　例如，N=4，M=2，面值分别为4分，1分，于是形成1，2，3，4，5，6，7，8，9，10，12，13，16的序列，而从1开始的连续邮资序列为1，2，3，4，5，6，7，8，9，10，所以连续邮资序列的最大值为10分。
输入格式
　　第一行：最多允许粘贴的邮票张数N；第二行：邮票种数M；第三行：空格隔开的M个数字，表示邮票的面值Xi。注意：Xi序列不一定是大小有序的！
输出格式
　　从1开始的连续邮资序列的最大值MAX。若不存在从1分开始的序列（即输入的邮票中没有1分面额的邮票），则输出0.
样例输入
样例一：
4
2
4 1
样例二：
10
5
2 4 6 8 10

样例输出
样例一：
10
样例二：
0

---------------------------------------------
#include<bits/stdc++.h>
using namespace std;
int main () {
	int n, m, ans;
	scanf("%d %d", &n, &m);
	vector<int> v(m);
	for (int i = 0; i < m; i++) {
		scanf("%d", &v[i]);
	}
	sort(v.begin(), v.end());
	vector<int> dp(v[v.size() - 1] * n + 1);
	for (int i = 1; i <= v[v.size() - 1] * n; i++) {
		for (int j = 0; j < v.size(); j++) {
//		for (int j = v.size() - 1; j >= 0; j--) {// 都可？ 
			if ((dp[i] == 0 || dp[i - v[j]] < dp[i]) && i >= v[j]) {
				dp[i] = dp[i - v[j]] + 1;
			}
		}
		if (dp[i] == 0 || dp[i] > n) {
			printf("%d\n", i - 1);
			break;
		}
	}
	return 0;
}

-----------------------------------------------------
鸣谢
  https://blog.csdn.net/weixin_45269353/article/details/104557530
  
判断有没有k∈[1, n]满足邮票总值s=i，i∈[1, maxStamp*n] -> 找各s对应的最小的k即可
数组dp记录各邮票总值s的k，以下两种情况即给出程序结果
  1. 若k=0: 不存在s=i的情况; 
  2. 若k>n: 贴邮票的位置不够
双层循环
