问题描述

　　今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：

　　设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。

　　同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：

　　有一个数字串：312， 当N=3，K=1时会有以下两种分法：

　　3*12=36
　　31*2=62

　　这时，符合题目要求的结果是：31*2=62

　　现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。

输入格式

　　程序的输入共有两行：
　　第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）
　　第二行是一个长度为N的数字串。


输出格式

　　输出所求得的最大乘积（一个自然数）。

　　样例输入

　　4 2
　　1231
样例输出
62


------------------------------------------------------
#include<bits/stdc++.h>
using namespace std;
int main () {
	int n, k;
	string s;
	scanf("%d %d", &n, &k);
	getchar();
	getline(cin, s);
	vector<int> a(n);
	vector<vector<long long> > dp;
	dp.resize(n, vector<long long>(n));
	for (int i = 0; i < n; i++) {
		a[i] = s[i] - '0';
	}
	long long tmp = 0;
	for (int i = 0; i < n; i++) {
		tmp = tmp * 10 + a[i];
		dp[i][0] = tmp; 
	}
	for (int i = 1; i < n; i++) {
		for (int j = 1; j <= i; j++) {
			dp[i][j] = dp[i - 1][j - 1] * (dp[i][0] - (dp[i - 1][0] * pow(10, 1)));
			for (int k = 1; k < i; k++) {
				if (dp[i][j] < dp[k - 1][j - 1] * (dp[i][0] - (dp[k - 1][0] * pow(10, i - k + 1)))) {
					dp[i][j] = dp[k - 1][j - 1] * (dp[i][0] - (dp[k - 1][0] * pow(10, i - k + 1)));
				}
			}
		}
	}
	cout << dp[n - 1][k];
	return 0;
}

---------------------------------------------------------
鸣谢
  https://blog.csdn.net/practical_sharp/article/details/102943878

算法中用dp[i][j]表示从第1个数字到第i个数字中加入j个乘号之后的最优值。
i个数字中最多能够加入i-1个乘法符号，那么1<=j<=i-1。

如果在0到i-1中的k处断开，将序列分成0到k-1段和k到i-1段
在断开的地方加入乘号（k的取值范围：1<=k<i），那么此时
dp[i][j]=dp[k-1][j-1]*(从第k到i连续的数字组成的整数值)
即dp[i][j]=dp[k-1][j-1]*(dp[i][0]-(dp[k-1][0]*10^(i-(k-1))));

dp[i][0]表示从第1个数字到第i个数字自然连接的整数值。
