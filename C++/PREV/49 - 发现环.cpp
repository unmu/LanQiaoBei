问题描述
　　小明的实验室有N台电脑，编号1~N。原本这N台电脑之间有N-1条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。


　　不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了BUG。


　　为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？
输入格式
　　第一行包含一个整数N。
　　以下N行每行两个整数a和b，表示a和b之间有一条数据链接相连。


　　对于30%的数据，1 <= N <= 1000
　　对于100%的数据, 1 <= N <= 100000， 1 <= a, b <= N


　　输入保证合法。
输出格式
　　按从小到大的顺序输出在环路上的电脑的编号，中间由一个空格分隔。
样例输入
5
1 2
3 1
2 4
2 5
5 3
样例输出
1 2 3 5

-----------------------------------------------------
遍历全部结点，每次删掉度为一的结点
#include<bits/stdc++.h>
using namespace std;
vector<int> g[100005], book(100005);
int main () {
	int n, u, v;
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf("%d %d", &u, &v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	while (1) {
		int flag = 1;
		for (int i = 1; i <= n; i++) {
			if (book[i] == 0 && g[i].size() == 1) {
				book[i] = 1;
				flag = 0;
			}
		}
		if (flag) {
			break;
		}
		for (int i = 1; i <= n; i++) {
			if (book[i] == 0) {
				for (int j = 0; j < g[i].size(); j++) {
					if (book[g[i][j]] == 1) {
						g[i].erase(g[i].begin() + j);
						j--;
					}
				}
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		if (book[i] == 0) {
			printf("%d ", i);
		}
	} 
	return 0;
}
