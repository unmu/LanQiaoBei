 问题描述

如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。
输入格式

输入包含两个正整数，K和L。
输出格式
输出一个整数，表示答案对1000000007取模后的值。
样例输入
4 2
样例输出
7
数据规模与约定

对于30%的数据，KL <= 106；

对于50%的数据，K <= 16， L <= 10；

对于100%的数据，1 <= K,L <= 100。

--------------------------------------
#include<bits/stdc++.h>
using namespace std;
int main () {
	int k, l;
	scanf("%d %d", &k, &l);	// k进制，l位数 
	vector<vector<int> > dp;
	dp.resize(l, vector<int>(k));
	for (int i = 1; i < l; i++) {
		for (int j = 0; j < k; j++) {
			for (int p = 0; p < k; p++) {
				if (i == l - 1 && j == 0) {
					continue;
				}
				if (abs(j - p) > 1 || j == p) {
					if (i == 1) {
						dp[i][j] += 1;
					} else {
						dp[i][j] = (dp[i][j] + dp[i - 1][p]) % 1000000007; 
					}
				}
			}
		}
	}
	int ans = 0;
	for (int i = 0; i < k; i++) {
		ans = (ans + dp[l - 1][i]) % 1000000007;
	}
	printf("%d", ans);
	return 0;
}

---------------------------------
思路来源：https://blog.csdn.net/qq_41714549/article/details/87435089 
  用dp[i][j]=dp[i][j]+dp[i-1][k]来做。解释一下：这里的i 代表所在的位数（i=0代表个位，i=1代表十位，以此类推）。j 代表取K进制数的一个数(如果是4进制数，那么j取[0,3]中的一个数)。k和j同一个意思。整个式子的意思是当前位置的数总数=当前位置的数的数目+前一个位置的数的总数。
